# vim: set ft=ruby
class OreScript::Parser
  options no_result_var
rule
    program : expressions
    expressions : expression
                  { [:exprs, [val[0]]] }
                | expressions expression
                  { [:exprs, val[0][1] + [val[1]]] }
    expression : let
               | function
               | fcall
               | if
               | varref
               | literal
               | '(' expression ')' { val[1] }
    let : VAR '=' expression
          { [:let, val[0], val[2]] }
    function : 'fn' '(' params ')' '{' expressions '}' 
               { [:function, val[2], val[5]] }
    params : VAR
           { [val[0]] }
         | params ',' VAR
           { val[0].push(val[2]) }
    fcall : expression '(' args ')'
            { [:fcall, val[0], val[2]] }
    args : expression
           { [val[0]] }
         | args ',' expression
           { val[0].push(val[2]) }
    if : 'if' '(' expression ')' '{' expressions '}' 'else' '{' expressions '}'
         { [:if, val[2], val[5], val[9]] }

    varref : VAR
             { [:varref, val[0]] }

    literal : number | bool
    number : NUMBER
             { [:literal, "number", val[0]] }
    bool : 'true' 
           { [:literal, "bool", true] }
         | 'false'
           { [:literal, "bool", false] }
end

---- header
require 'strscan'

---- inner
def parse(str)
  @q = []
  s = StringScanner.new(str)
  until s.empty?
    case
    when s.scan(/\s+/)
      # skip whitespace
    when m = s.scan(/[(){},=]/)
      @q << [m, nil]
    when m = s.scan(/\d+(\.\d+)?/)
      @q << [:NUMBER, m.to_f]
    when m = s.scan(/true|false|fn|if|else/)
      @q << [m, m.to_sym]
    when m = s.scan(/\w+/)
      @q << [:VAR, m]
    else
      raise "no match: #{s.inspect}"
    end
  end

  do_parse
end

def next_token
  @q.shift
end
